// Цвета:

var colorBackground = "#ffffff";                           // Цвет фона
var colorClock1 = "#808080";                               // Цвет цифровых часов (auoen)
var colorClock2 = "#505050";                               // Цвет фона дисплея
var colorClock3 = "#ff0000";                               // Цвет цифр
var colorElongation = "#008000";                           // Цвет для потенциальной
var colorVelocity = "#ff0000";                             // Цвет для кинетической
var colorAcceleration = "#0000ff";                         // Цвет для ускорения
var colorForce = "#008020";                                // Цвет для силы
var colorBody = "#ffffff";                                 // Цвет корпуса маятника

// Другие константы:

var DEG = Math.PI / 180;                                   // Угловой градус
var ax = 120, ay = 30;                                     // Положение подвеса (пиксели)
var xD = 260;                                              // начало координат x
var yD1 = 180, yD2 = 165;                                  // Начало координат y
var FONT1 = "normal normal bold 12px sans-serif";          // Набор символов
var tPix = 20;                                             // Коэффициент преобразования (пикселей в секунду)

var text01 = "Сброс";             // Сброс
var text02 = ["Старт", "Пауза", "Продолжить"];
var text03 = "Замедленное движение";                         // Замедленное движение (2)
var text04 = "Длина маятника:";              // Длина маятника (2)
var text05x = "Гравитационное";                                // Ускорение падения (2)
var text05 = "ускорение:";        // Ускорение падения (3)
var text06 = "Масса:";                                // Масса
var text07 = "Амплитуда:";        // Амплитуда
var text08 = "Отклонение";   // Удлинение
var text09 = "Скорость";               // Скорость
var text10 = "Ускорение";         // Ускорение
var text11 = "Сила";                                       // Сила
var text12 = "Энергия";                     // Энергия
var textNothing = "Отключить";                     // Энергия

// Символы и единицы измерения:

var decimalSeparator = ",";                                // Десятичный разделитель (запятая/ точка)

var meter = "м (лимит 0,5-10)";
var meterPerSecond2 = "м/с&sup2 (лимит 1-100);";
var kilogram = "кг (лимит 1-10)";
var degree = "&deg; (лимит 2-20)";

var text13 = "Максимум";               // Максимум
var text14 = "Отклонение";   // Удлинение
var text15 = "Скорость";               // Скорость
var text16 = "Ускорение (объекта)";  // Ускорение, тангенциальная составляющая (3)
var text17 = "Сила (объекта)";  // Сила, тангенциальная составляющая (3)
var text18 = "Потенциальная энергия";                                         // Потенциальная энергия (2)
var text19 = "Кинетическая энергия";                                         // Кинетическая энергия (2)
var text20 = "Полная энергия";                     // Полная энергия (2)
var text21 = "(с)";                                   // Единица измерения для Временная шкала (ы)
var text22 = "(м)";                                   // Единица измерения для вертикальной оси (м)
var text23 = "(м/с)";                            // Единица измерения для вертикальной оси (м/с)
var text24 = "(м/с²)";                      // Единица измерения для вертикальной оси (м/со)
var text25 = "(Н)";                                   // Единица измерения для вертикальной оси (N)
var text26 = "(Дж)";                             // Единица измерения для вертикальной оси (J)
var text27 = "Период колебаний";         // Период колебаний (2)

// Символы и единицы измерения:

var symbolTime = "t";                                      // Символ времени
var symbolElongation = "s";                                // Символ удлинения
var symbolVelocity = "v";                                  // Символ скорости
var symbolAcceleration = "a";                              // Символ ускорения
var symbolTangential = "tang";                             // Символ касательной
var symbolForce = "F";                                     // Символ силы
var symbolEnergy = "E";                                    // Символ энергии
var symbolPotential = "pot";                               // Символ потенциала
var symbolKinetic = "kin";                                 // Символ кинетики
var second = "с";
var meterUnicode = "м";
var meterPerSecond = "м/с";
var meterPerSecond2Unicode = "м/с²";
var newton = "Н";
var joule = "Дж";


// Атрибуты:

var canvas, ctx;                                           // Область рисования, графический контекст
var width, height;                                         // Размеры области рисования (пиксели)
var bu1, bu2;                                              // Кнопки переключения передач (сброс, запуск/пауза/Продолжение)
var cbSlow;                                                // Переключатель замедленного воспроизведения
var ipL, ipG, ipM, ipA;                                    // Поля ввода
var rbY, rbV, rbA, rbF, rbE;                               // Радиокнопки
var on;
var slow;                                                  // Флаг для замедленного воспроизведения 
var t0;                                                    // Начальное время
var t;                                                     // Текущее время (ы)
var tU;                                                    // Время для начала (ов) диаграммы
var l;                                                     // Длина маятника (м)
var lPix;                                                  // Длина маятника (пикселей)
var g;                                                     // Ускорение падения (м / с)
var m;                                                     // Масса (кг)
var omega;                                                 // Круговая частота (колесо / с)
var tPer;                                                  // Продолжительность колебаний (с)
var phi;                                                   // Фазовый угол (дуговой мао)
var sinPhi, cosPhi;                                        // Тригонометрические значения
var alpha0;                                                // Максимальный угол отклонения (Мао дуги)
var alpha;                                                 // Мгновенный угол отклонения (дуга Мао)
var sinAlpha, cosAlpha;                                    // Тригонометрические значения
var yPix;                                                  // Коэффициент преобразования (пиксели на единицу СИ)
var px, py;                                                // Положение тела маятника (пиксели)
var nrSize;                                                // Количество рассмотренных грув

// Элемент таблицы (как HTML-дата):
// идентификатор ..... Идентификатор HTML-Befehl
// текст ... Текст (необязательно)

function getElement(id, text) {
  var e = document.getElementById(id);                     // Элемент
  if (text) e.innerHTML = text;                            // Задать текст, если он определен
  return e;                                                // Заданное значение юбки
}

// Начать:

function start() {
  canvas = getElement("cv");                               // Область рисования
  width = canvas.width; height = canvas.height;            // Размеры (пиксели)
  ctx = canvas.getContext("2d");                           // Графический контекст
  bu1 = getElement("bu1", text01);                         // Кнопка сброса
  bu2 = getElement("bu2", text02[0]);                      // Кнопка запуска
  bu2.state = 0;                                           // Начальное состояние (до начала анимации)
  cbSlow = getElement("cbSlow");                           // Переключатель (замедленное воспроизведение)
  cbSlow.checked = false;                                  // Замедленное воспроизведение отключено
  getElement("lbSlow", text03);                            // Озвучивание текста (замедленное воспроизведение)
  getElement("ipLa", text04);                              // Озвучивание текста (замедленное воспроизведение)
  ipL = getElement("ipLb");                                // Поле ввода (длина маятника)
  getElement("ipLc", meter);                               // Единица измерения (длина маятника)
  var ipgx = getElement("ipGx");                           // Дополнительная строка (ускорение падения)
  if (ipgx) ipgx.innerHTML = text05x;                      // Пояснительный текст, дополнительная строка (ускорение падежа)
  getElement("ipGa", text05);                              // Пояснительный текст (ускорение падежа)
  ipG = getElement("ipGb");                                // Поле ввода (ускорение падения)
  getElement("ipGc", meterPerSecond2);                     // Единица измерения (ускорение падения)
  getElement("ipMa", text06);                              // Озвученный текст (объем)
  ipM = getElement("ipMb");                                // Поле ввода (объем)
  getElement("ipMc", kilogram);                            // Единица измерения (масса)
  getElement("ipAa", text07);                              // Озвучивающий текст (амплитуда)
  ipA = getElement("ipAb");                                // Поле ввода (амплитуда)
  getElement("ipAc", degree);                              // Единица измерения (амплитуда)
  rbY = getElement("rbY");                                 // Радиокнопка (удлинение)
  getElement("lbY", text08);                               // Озвучивающий текст (удлинение)
  //rbY.checked = true;                                      // Выделить радиокнопку
  rbV = getElement("rbV");                                 // Радиокнопка (скорость)
  getElement("lbV", text09);                               // Озвучивание текста (скорость)
  rbA = getElement("rbA");                                 // Радиокнопка (ускорение)
  getElement("lbA", text10);                               // Озвучивание текста (ускорение)
  rbF = getElement("rbF");                                 // Радиокнопка (сила)
  getElement("lbF", text11);                               // Озвучивание текста (сила)
  rbE = getElement("rbE");                                 // Радиокнопка (питание)
  getElement("lbE", text12);                               // Озвучивание текста (питание)
  rNth = getElement("rNth");
  getElement("lNth", textNothing);
  rNth.checked = true;

  l = 5;                                                   // Начальное значение длины маятника (м)
  g = 9.81;                                                // Начальное значение ускорения падения (м/со)
  m = 1;                                                   // Начальное значение массы (кг)
  alpha0 = 10 * DEG;                                       // Начальное значение угловой амплитуды (дуговое мао)
  updateInput();                                           // Обновить поля ввода
  calculation();                                           // Вычисления (эффект страницы!)
  focus(ipL);                                              // Фокусировка для первого поля ввода
  on = false;                                              // Анимация отключена
  slow = false;                                            // Замедленное движение отключено
  t = 0;                                                   // Текущее время (ы)
  t0 = new Date();                                         // Начальное время
  setInterval(paint, 40);                                  // Интервал таймера 0,040 с

  bu1.onclick = reactionReset;                             // Реакция на кнопку сброса
  bu2.onclick = reactionStart;                             // Реакция на кнопку запуска
  cbSlow.onclick = reactionSlow;                           // Реакция на переключатель замедленного действия
  ipL.onkeydown = reactionEnter;                           // Реакция на клавишу Enter (ввод в режиме ожидания)
  ipG.onkeydown = reactionEnter;                           // Реакция на клавишу Enter (ускорение ввода)
  ipM.onkeydown = reactionEnter;                           // Реакция на клавишу Enter (ввод массы)
  ipA.onkeydown = reactionEnter;                           // Реакция на клавишу Enter (амплитуда ввода)
  ipL.onblur = reaction;                                   // Реакция на потерю фокуса (ввод)
  ipG.onblur = reaction;                                   // Реакция на потерю фокуса (входное ускорение падения)
  ipM.onblur = reaction;                                   // Реакция на потерю фокуса (ввод массы)
  ipA.onblur = reaction;                                   // Реакция на потерю фокуса (входная амплитуда)
  rNth.onclick = reactionRadioButton;                       // Реакция на ничего радиокнопки
  rbY.onclick = reactionRadioButton;                       // Реакция на удлинение радиокнопки
  rbV.onclick = reactionRadioButton;                       // Реакция на скорость радиокнопки
  rbA.onclick = reactionRadioButton;                       // Реакция на ускорение радиокнопки
  rbF.onclick = reactionRadioButton;                       // Реакция на силу радиокнопки
  rbE.onclick = reactionRadioButton;                       // Реакция на энергию радиокнопки
  nrSize = 5;                                              // Удлинение сбалансировано

} // Конец метода пуск

// Настройка состояния для кнопки Пуск/Пауза/Далее:

function setButton2State(st) {
  bu2.state = st;                                          // Сохранить состояние
  bu2.innerHTML = text02[st];                              // Обновить текст
}

// Переключение кнопки Пуск/Пауза/Продолжить:

function switchButton2() {
  var st = bu2.state;                                      // Текущее состояние
  if (st == 0) st = 1;                                     // Если начальное состояние, запуск
  else st = 3 - st;                                          // Переключение между анимацией и прерыванием
  setButton2State(st);                                     // Сохранить новое состояние, добавить текст /
}

// Активация или прерывание. Включение поля ввода:
// с... Флажок для возможного ввода

function enableInput(p) {
  ipL.readOnly = !p;                                       // Поле ввода для длины маятника
  ipG.readOnly = !p;                                       // Поле ввода для ускорения падения падения
  ipM.readOnly = !p;                                       // Поле ввода для массы
  ipA.readOnly = !p;                                       // Поле ввода для угловой амплитуды
}

// Реакция на кнопку сброса:
// Боковой эффект t, tU, on, slow

function reactionReset() {
  setButton2State(0);                                      // Состояние кнопки Пуск /Пауза/Продолжить
  enableInput(true);                                       // Включить поля ввода
  t = tU = 0;                                              // Установить переменную времени
  on = false;                                              // Анимация отключена
  slow = cbSlow.checked;                                   // Флаг для замедленного воспроизведения
  reaction();                                              // Принять введенные значения, выполнить вычисления, перерисовать
  focus(ipL);                                              // Фокус для первое поле ввода
}

// Реакция на кнопку Пуск/Пауза /Далее:
// Эффект страницы t, tU, on, slow, l, g, m, альфа 0, омега, PPX, фи, синфа, Косфи, альфа, синалфа, косальфа, пиксель, пи

function reactionStart() {
  if (bu2.state != 1) t0 = new Date();                     // Если анимация включена, новое начальное время
  switchButton2();                                         // Состояние переключателя в другом месте
  enableInput(false);                                      // Отключение полей ввода
  on = (bu2.state == 1);                                   // Флаг для анимации
  slow = cbSlow.checked;                                   // Флаг для замедленного воспроизведения
  reaction();                                              // Принимать введенные значения, вычислять, перерисовывать
}

// Реакция переключателя Замедленное воспроизведение:
// Эффект замедленной съемки

function reactionSlow() {
  slow = cbSlow.checked;                                   // Установить флаг
}

// Вспомогательная процедура: вводить, вычислять, перерисовывать
// Эффект страницы l, g, m, альфа 0, омега, tPer, lPix

function reaction() {
  input();                                                 // Принять введенные значения (возможно, исправленные)
  calculation();                                           // Расчеты
  paint();                                                 // Перерисовка
}

// Реакция на нажатие клавиши (только на клавишу Enter):

function reactionEnter(e) {
  var enter = (e.key == "Enter" || e.code == "Enter");     // Флаг для клавиши ввода
  if (!enter) return;                                      // Если другая клавиша, отмена
  reaction();                                              // Получение данных, вычисление, перерисовка
}

// Фокус для поля ввода, курсор в конце:
// ис ... Поле ввода

function focus(ip) {
  ip.focus();                                              // Фокус для поля ввода
  var n = ip.value.length;                                 // Удлинение строки
  ip.setSelectionRange(n, n);                               // Установка курсора
}

// Реакция на радиокнопку:
// Изменение размера страницы

function reactionRadioButton() {
  if (rbY.checked) nrSize = 0;                             // Либо удлинение ...
  else if (rbV.checked) nrSize = 1;                        // ... или скорость ...
  else if (rbA.checked) nrSize = 2;                        // ... или ускорение ...
  else if (rbF.checked) nrSize = 3;                        // ... или сила ...
  else if (rNth.checked) nrSize = 5;                        // ... или ничего ...
  else nrSize = 4;                                         // ... или выделять энергию
}

//-------------------------------------------------------------------------------------------------

// Расчеты:
// Побочный эффект омега, tPer, lPix

function calculation() {
  omega = Math.sqrt(g / l);                                  // Круговая частота (рад/с)
  tPer = 2 * Math.PI / omega;                                  // Продолжительность колебаний (с)
  lPix = 25 * l;                                             // Длина маятника (пиксель)
}

// Преобразование числа в строку:
// n ..... Заданное число
// d ..... количество цифр
// fix ... Flag для знаков после запятой (в отличие от золотых цифр)

function ToString(n, d, fix) {
  var s = (fix ? n.toFixed(d) : n.toPrecision(d));         // Строка с десятичной
  return s.replace(".", decimalSeparator); точкой // Возможно заменить точку запятой
}

// Ввод числа
// ef .... Поле ввода
// d ..... количество цифр
// fix ... Flag для знаков после запятой (в отличие от золотых цифр)
// минимум ... минимум разрешенного диапазона
// максимум ... Максимум разрешенного диапазона
// Заданное значение: число или NaN

function inputNumber(ef, d, fix, min, max) {
  var s = ef.value;                                        // Строка в поле ввода
  s = s.replace(",", ".");                                  // Возможно преобразовать запятую в точку
  var n = Number(s);                                       // преобразование в число, если возможно
  if (isNaN(n)) n = 0;                                     // Интерпретировать бессмысленный ввод как 0
  if (n < min) n = min;                                    // Если число слишком мало, исправьте // Если число слишком мало, измените // Если нет, измените значение на NaN // Если нет, измените значение на NaN // Если нет, измените значение на NaN // Если нет // Если нет // Если нет // Если нет // Если нет // Если нет // Если нет // Если нет // Если нет // Если число слишком мало, исправьте
  if (n > max) n = max;                                    // Если Число в groo, исправить
  ef.value = ToString(n, d, fix);                            // Поле ввода может быть исправлено
  return n;                                                // Заданное значение объекта
}

// Весь ввод:
// Боковой эффект l, g, m, alpha0

function input() {
  var ae = document.activeElement;                         // Активный элемент
  l = inputNumber(ipL, 3, true, 0.5, 10);                      // Длина подвески (m)
  g = inputNumber(ipG, 2, true, 1, 100);                       // Ускорение падения (м/со)
  m = inputNumber(ipM, 3, true, 1, 10);                        // Масса (кг)
  alpha0 = DEG * inputNumber(ipA, 1, true, 2, 20);               // Угловая амплитуда (мао дуги)
  if (ae == ipL) focus(ipG);                               // Фокус для последнего поля ввода
  if (ae == ipG) focus(ipM);                               // Фокус для последнего поля ввода
  if (ae == ipM) focus(ipA);                               // Фокус для последнего поля ввода
  if (ae == ipA) ipA.blur();                               // Фокус передан
}

// Обновление полей ввода:

function updateInput() {
  ipL.value = ToString(l, 3, true);                          // Поле ввода для Pendellonge (m)
  ipG.value = ToString(g, 2, true);                          // Поле ввода для ускорения падения (м/со)
  ipM.value = ToString(m, 3, true);                          // Поле ввода для массы (кг)
  ipA.value = ToString(alpha0 / DEG, 1, true);                 // Поле ввода для угловой амплитуды (о)
}

//-------------------------------------------------------------------------------------------------

// Новый контур со значениями по умолчанию:

function newPath() {
  ctx.beginPath();                                         // Новый контур
  ctx.strokeStyle = "#000000";                             // Цвет линии черный
  ctx.lineWidth = 1;                                       // Толщина линии 1
}

// Прямоугольник с черной рамкой:
// (x,y) ... Координаты верхнего левого угла (пиксели)
// вт ....... ширина (пиксели)
// час ....... Высота (пиксели)
// c ....... Цвет подписки (необязательно)

function rectangle(x, y, w, h, c) {
  if (c) ctx.fillStyle = c;                                // Следующий цвет
  newPath();                                               // Новый контур
  ctx.fillRect(x, y, w, h);                                   // Развернуть прямоугольник
  ctx.strokeRect(x, y, w, h);                                 // Нарисовать границу
}

// Круг с черной границей:
// (x, y) ... Координаты центральной точки (пиксели)
// r ....... радиус (пиксель)
// c ....... Цвет подписки (необязательно)

function circle(x, y, r, c) {
  if (c) ctx.fillStyle = c;                                // Цвет перехода
  newPath();                                                // Новый контур
  ctx.arc(x, y, r, 0, 2 * Math.PI, true);                         // Подготовить круг
  ctx.fill();                                              // Развернуть круг
  ctx.stroke();                                            // Нарисовать границу
}

// Нарисовать маятник:
// Боковой эффект альфа, синалфа, косалфа, пиксель, пи

function pendulum() {
  alpha = alpha0 * cosPhi;                                   // Отклонение (дуга мао)
  sinAlpha = Math.sin(alpha);                              // Значение синуса
  cosAlpha = Math.cos(alpha);                              // Значение косинуса
  px = ax + lPix * sinAlpha;                                   // x-координата маятника (пиксель)
  py = ay + lPix * cosAlpha;                                   // y-координата тела маятника (пиксели)
  newPath();                                               // Новый путь со значениями по умолчанию
  ctx.moveTo(ax, ay);                                       // Начальная точка (зависание)
  ctx.lineTo(px, py);                                       // Переход к центральной точке корпуса маятника
  ctx.closePath();                                          // Проложите путь
  ctx.stroke();                                            // Нарисуйте линию для шнура
  circle(px, py, 5, '#000000');                               // Корпус маятника
}

// Нарисуйте цифровые часы:

/* function clock(x, y) {
  rectangle(x - 60, y - 16, 120, 32, colorClock1);                 // Корпус
  rectangle(x - 50, y - 10, 100, 20, colorClock2);                 // Фон дисплея
  ctx.fillStyle = "#ff0000";                               // Цвет для цифр
  ctx.font = "normal normal bold 16px monospace";          // Набор символов
  ctx.textAlign = "center";                                // Вывод по центру
  var n = Math.floor(t / 1000);                              // Количество временных отрезков по 1000 с
  var s = (t - n * 1000).toFixed(3) + " " + second;         // Указание времени (единица с, начало каждые 1000 с)
  s = s.replace(".", decimalSeparator);                     // Возможно, заменить точку запятой
  while (s.length < 9) s = " " + s;                          // Заменить пробел в начале, возможно
  ctx.fillText(s, x, y + 5);                                   // Вывести время
} */

// Нарисовать стрелку:
// x1, y1 ... начальная точка
// x2, y2 ... конечная точка
// вт ....... Толщина линии (необязательно)
// Обратите внимание: цвет определяется ctx.strokeStyle.

function arrow(x1, y1, x2, y2, w) {
  if (!w) w = 1;                                           // Если толщина линии не определена, значение по умолчанию
  var dx = x2 - x1, dy = y2 - y1;                          // Векторные координаты
  var length = Math.sqrt(dx * dx + dy * dy);                     // Выпад
  if (length == 0) return;                                 // Отмена, если выпад 0
  dx /= length; dy /= length;                              // Единичный вектор
  var s = 2.5 * w + 7.5;                                       // Выпад наконечника стрелы 
  var xSp = x2 - s * dx, ySp = y2 - s * dy;                        // Вспомогательная точка для наконечника стрелы
  var h = 0.5 * w + 3.5;                                    // Половина ширины наконечника стрелы
  var xSp1 = xSp - h * dy, ySp1 = ySp + h * dx;                    // Угол наконечника стрелы
  var xSp2 = xSp + h * dy, ySp2 = ySp - h * dx;                    // Угол наконечника стрелы
  xSp = x2 - 0.6 * s * dx; ySp = y2 - 0.6 * s * dy;                    // Переходящий угол стрелки
  ctx.beginPath();                                         // Новый путь
  ctx.lineWidth = w;                                       // Толщина линии
  ctx.moveTo(x1, y1);                                       // Начальная точка
  if (length < 5) ctx.lineTo(x2, y2);                       // Если стрелка короткая, продолжайте движение к конечной точке, ...
  else ctx.lineTo(xSp, ySp);                                // ... в противном случае перейдите к переходному углу
  ctx.stroke();                                            // Нарисуйте линию
  if (length < 5) return;                                  // Если стрелка короткая, наконечника нет
  ctx.beginPath();                                         // Новый путь для точки со стрелкой
  ctx.fillStyle = ctx.strokeStyle;                         // Следующий цвет, как цвет линии
  ctx.moveTo(xSp, ySp);                                    // Начальная точка (переходящий угол)
  ctx.lineTo(xSp1, ySp1);                                  // Переход к точке с одной стороны
  ctx.lineTo(x2, y2);                                      // Переход к точке с другой стороны
  ctx.lineTo(xSp2, ySp2);                                   // Переход к точке с другой стороны
  ctx.closePath();                                         // Переход к начальной точке
  ctx.fill();                                               // Рисование точки со стрелкой
}

// Векторная стрелка от корпуса маятника:
// р ..... Выпад стрелы
// фи ... Угол, противоположный горизонтали (дуга Мао, против часовой стрелки)

function arrowPendulum(r, phi) {
  var x = px + r * Math.cos(phi);                              // x-координата стрелки
  var y = py - r * Math.sin(phi);                              // y-координата стрелки
  arrow(px, py, x, y, 3);                                      // нарисовать стрелку
}

// выровнять текст (набор символов FONT1):
// s ...... строка
// t ...... тип (0 для левого угла, 1 для центрированного, 2 для правого угла)
// (x, y) ... Положение (пиксель)

function alignText(s, t, x, y) {
  ctx.font = FONT1;                                        // Набор символов
  if (t == 0) ctx.textAlign = "left";                      // слева направо в зависимости от значения t ...
  else if (t == 1) ctx.textAlign = "center";               // ... или центрированный ...
  else ctx.textAlign = "right";                            // ... или в верхнем правом углу
  ctx.fillText(s, x, y);                                     // вывод текста
}

// Горизонтальная ось (с метками и тиками) для диаграммы:
// (x,y) ... Начало координат (пиксели)

function horizontalAxis(x, y) {
  ctx.strokeStyle = "#000000";                             // Цвет линии черный
  arrow(x - 20, y, x + 240, y);                                   // Нарисовать стрелку
  alignText(symbolTime, 1, x + 230, y + 15);                      // Надпись (т)
  alignText(text21, 1, x + 230, y + 27);                          // Метка (в единицах)
  var t0 = Math.ceil(tU);                                  // Время (ы) для первого тика
  var x0 = Math.round(x + tPix * (t0 - tU));                    // x-координата первого тика
  for (i = 0; i <= 10; i++) {                                  // Для всех тиков ...
    var xs = x0 + i * tPix;                                    // Вычислить координату x
    ctx.moveTo(xs, y - 3); ctx.lineTo(xs, y + 3);                // Подготовить тик
    if (xs >= x + 5 && xs <= x + 215                           // Если тик не слишком далеко влево или не слишком далеко вправо ...
      && (t0 + i <= 100 || (t0 + i) % 2 == 0))                     // и время (ы) меньше 100 или четное число ...
      alignText("" + (t0 + i), 1, xs, y + 13);                      // ... Пометить тик
  }
  ctx.stroke();                                            // Нарисовать тики
}

// Вертикальная ось (с меткой и тиками) для диаграммы:
// (x,y) ... Начало координат (пиксели)
// yLow .... Нижний конец оси (пиксели)
// ИГХ ... Верхний конец оси (пиксели)
// maxSI ... Максимальное значение (единица СИ)
// Боковой эффект yPix

function verticalAxis(x, y, yLow, yHigh, maxSI) {
  var pot10 = Math.pow(10, Math.floor(Math.log(maxSI) / Math.LN10));    // Еще меньше степени десяти до maxSI
  var q = maxSI / pot10;                                     // Удержание (от 1 до 10)
  var n;                                                   // Количество тиков
  if (q > 5) n = 10; else if (q > 2) n = 5; else n = 2;    // "Плавное" значение для количества тиков
  ctx.strokeStyle = "#000000";                             // Цвет линии черный
  arrow(x, yLow, x, yHigh);                                   // Нарисовать стрелку
  var n0 = (nrSize < 4 ? -n : 0);                            // Номер самого нижнего тика
  ctx.beginPath();                                         // Новый путь
  for (i = n0; i <= n; i++) {                                  // Для всех тиков ...
    var ys = y - i * 100 / n;                                    // y-координата тика
    ctx.moveTo(x - 3, ys); ctx.lineTo(x + 3, ys);                // Подготовить тик
    var s = Number(i * pot10).toPrecision(1);                // строка для метки
    if (Math.abs(i * pot10) >= 10)                           // Если необходимо ...
      s = "" + Math.round(i * pot10);                          // ... Не допускать написания в степени десяти
    s = s.replace(".", decimalSeparator);                    // Возможно, превратить точку в запятую
    if ((n < 10 || i % 2 == 0) && i != 0)                    // Если это имеет смысл ... 
      alignText(s, 2, x - 3, ys + 4);                             // ... Обозначить тик
  }
  ctx.stroke();                                            // Нарисовать тики
  yPix = 100 / n / pot10;                                      // Обновить коэффициент пересчета
}

// Синусоидальная кривая (увеличение с помощью многоугольника):
// (x,y) ... Нулевая точка (пиксель)
// за ..... период (пиксели)
// амплитуда .... Амплитуда (пиксель)
// xMin .... Минимальное значение x (пикселей)
// xMax .... Максимальное значение x (пикселей)

function sinus(x, y, per, ampl, xMin, xMax) {
  var omega = 2 * Math.PI / per;                               // Вспомогательная канавка
  newPath();                                                // Новый путь (значения по умолчанию)
  var xx = xMin;                                           // x-координата для левого края
  ctx.moveTo(xx, y - ampl * Math.sin(omega * (xx - x)));            // Начальная точка
  while (xx < xMax) {                                       // Пока правый край еще не достигнут ...
    xx++;                                                  // увеличить координату x
    ctx.lineTo(xx, y - ampl * Math.sin(omega * (xx - x)));          // Подготовить новый участок
  }
  ctx.stroke();                                            // Нарисовать многоугольник для кривой
}

// Нарисовать диаграмму:

function diagram(type, x, y, yMax) {
  horizontalAxis(x, y);                                     // Горизонтальная ось с надписью и галочками
  verticalAxis(x, y, y + 120, y - 135, yMax);                      // Вертикальная ось с надписью и галочками
  sinus(x - type * tPer * 5 - tU * tPix, y, tPer * tPix, yMax * yPix, x, x + 200);   // Синусоидальная кривая  
}

// Отметка на графике для мгновенного значения:
// val .... Числовое значение (единица СИ)
// x, y ... Начало координат
// c ...... Цвет

function drawMomVal(val, x, y, c) {
  x += (t - tU) * tPix; y -= val * yPix;                         // Координаты центральной точки (пиксели)
  circle(x, y, 2, c);                                         // Маленький кружок с ободком
}

// Вывод числового значения:
// s ....... Обозначение Grooe
// v ....... Числовое значение
// u ........ Единица измерения
// n ........ Количество золотых цифр
// (x1,y) ... Положение текста (пиксели)
// (x2,y) ... Положение числового значения (пикселей)

function writeValue(s, v, u, n, x1, x2, y) {
  alignText(s + ":", 0, x1, y);                                 // Обозначение углубления
  s = v.toPrecision(n);                                    // Округление с требуемой точностью
  s = s.replace(".", decimalSeparator);                     // Может быть запятая вместо точки
  alignText(s + " " + u, 0, x2, y);                               // Число с единицей измерения
}

// Центрированный текст с индексом:
// s1 ...... Обычный текст
// s2 ..... индекс
// (x,y) ... позиция

function centerTextIndex(s1, s2, x, y) {
  var w1 = ctx.measureText(s1).width;                      // Ширина s1 (пикселей)
  var w2 = ctx.measureText(s2).width;                      // Ширина s2 (пикселей)
  var x0 = x - (w1 + w2) / 2;                                    // x-Координата центра
  alignText(s1, 0, x0, y);                                    // Вывод обычного текста
  alignText(s2, 0, x0 + w1 + 1, y + 5);                             // Вывод индекса
}

// Чертеж потенциалной энергии:
// Диаграмма временной зависимости удлинения, дуга окружности для удлинения, Числовые значения

function drawElongation() {
  var sMax = l * alpha0;                                     // Максимальная величина удлинения (м)
  var s = sMax * cosPhi;                                     // Мгновенное значение удлинения (м)
  diagram(1, xD, yD1, sMax);                                  // Нарисовать диаграмму
  alignText(symbolElongation, 1, xD - 25, yD1 - 130);             // Подпись (символ удлинения)
  alignText(text22, 1, xD - 25, yD1 - 118);                       // Маркировка (единица м)
  ctx.beginPath();                                         // Новый контур
  ctx.lineWidth = 3;                                       // Толщина значения линии
  ctx.strokeStyle = colorElongation;                        // Цвет для дуги окружности
  var pos = (alpha >= 0);                                   // Флаг для отклонения вправо
  var w0 = (pos ? Math.PI / 2 : Math.PI / 2 - alpha);            // Начальный угол для дуги окружности (дуги Мао)
  var w1 = (pos ? Math.PI / 2 - alpha : Math.PI / 2);            // Конечный угол для дуги окружности (дуга Мао)
  ctx.arc(ax, ay, lPix, w0, w1, true);                          // Подготовить дугу окружности
  ctx.stroke();                                             // Нарисовать дугу окружности
  drawMomVal(s, xD, yD1, colorElongation);                    // Отметить текущее значение на диаграмме
  ctx.fillStyle = colorElongation;                         // Цвет для удлинения (числовые значения)
  writeValue(text14, s, meterUnicode, 3, xD, xD + 200, height - 50); // Указать текущее значение
  writeValue("(" + text13, sMax, meterUnicode + ")", 3, xD, xD + 200, height - 30);  // Указать максимальное значение
}

// Чертеж на скорость:
// График зависимости скорости от времени, Стрелка для вектора скорости, Числовые значения

function drawVelocity() {
  var vMax = l * alpha0 * omega;                               // Максимальное значение скорости (м/с)
  var v = -vMax * sinPhi;                                    // Мгновенное значение скорости (м/с)
  diagram(2, xD, yD1, vMax);                                  // Нарисовать диаграмму
  alignText(symbolVelocity, 1, xD - 28, yD1 - 130);               // Надпись (символ скорости)
  alignText(text23, 1, xD - 28, yD1 - 118);                       // Метка (единица измерения м/с)
  ctx.strokeStyle = colorVelocity;                         // Цвет для скорости
  arrowPendulum(v * yPix, alpha0 * cosPhi);                     // Векторная стрелка для скорости
  drawMomVal(v, xD, yD1);                                    // Отметьте мгновенное значение на графике
  ctx.fillStyle = colorVelocity;                           // Цвет для скорости (числовые значения)
  writeValue(text15, v, meterPerSecond, 3, xD, xD + 200, height - 50);    // Укажите мгновенное значение
  writeValue("(" + text13, vMax, meterPerSecond + ")", 3, xD, xD + 200, height - 30);   // Укажите максимальное значение
}

// Рисунок тангенциального ускорения:
// График зависимости ускорения от времени, Стрелка для вектора ускорения, Числовые значения

function drawAcceleration() {
  var aMax = l * alpha0 * omega * omega;                          // Максимальная величина тангенциального ускорения (м/со)
  var a = -aMax * cosPhi;                                    // Мгновенное значение тангенциального ускорения (м/со)
  diagram(3, xD, yD1, aMax);                                  // Нарисовать график
  centerTextIndex(symbolAcceleration, symbolTangential, xD - 30, yD1 - 130);     // Подпись (Символ для тангенциальное ускорение)
  alignText(text24, 1, xD - 30, yD1 - 113);                       // Метка (единица измерения м/со)
  ctx.strokeStyle = colorAcceleration;                     // Цвет для ускорения
  arrowPendulum(a * yPix, alpha0 * cosPhi);                     // Векторная стрелка для тангенциального ускорения
  drawMomVal(a, xD, yD1);                                     // Отметьте мгновенное значение на графике
  ctx.fillStyle = colorAcceleration;                       // Цвет для ускорения (числовые значения)
  var mps2 = meterPerSecond2Unicode;
  writeValue(text16, a, mps2, 3, xD - 30, xD + 220, height - 50);     // Указать мгновенное значение
  writeValue("(" + text13, aMax, mps2 + ")", 3, xD - 30, xD + 220, height - 30); // Указать максимальное значение
}

// Рисунок касательной силы:
// График зависимости силы от времени, Стрелка для вектора силы, Числовые значения

function drawForce() {
  var fMax = m * l * alpha0 * omega * omega;                        // Максимальное значение касательной силы (N)
  var f = -fMax * cosPhi;                                    // Мгновенное значение касательной силы (N)
  diagram(3, xD, yD1, fMax);                                  // Нарисовать график
  centerTextIndex(symbolForce, symbolTangential, xD - 30, yD1 - 130);  // Подпись (символ для Касательная сила)
  alignText(text25, 1, xD - 30, yD1 - 113);                       // Метка (единица N)
  ctx.strokeStyle = colorForce;                            // Цвет для силы
  arrowPendulum(f * yPix, alpha0 * cosPhi);                     // Векторная стрелка для касательной силы
  drawMomVal(f, xD, yD1);                                     // Отметьте мгновенное значение на графике
  ctx.fillStyle = colorForce;                              // Цвет для силы (числовые значения)
  writeValue(text17, f, newton, 3, xD - 30, xD + 220, height - 50);    // Укажите мгновенное значение
  writeValue("(" + text13, fMax, newton + ")", 3, xD - 30, xD + 220, height - 30);   // Укажите максимальное значение
}

// График для Временная зависимость потенциальной и кинетической энергии:
// (x,y) .... Начало координат (пиксели)
// e ........ Полная энергия (Дж)

function diagramEnergy(x, y, e) {
  horizontalAxis(x, y);                                     // Горизонтальная ось с надписью и галочками
  verticalAxis(x, y, y + 20, y - 125, e);                          // Senkrechte Achse mit Beschriftung und Ticks
  var x1 = x + 200;                                          // x-координата для правого края (пиксель)
  var y1 = y - e * yPix;                                       // y-координата для полной энергии (пиксели)
  ctx.beginPath();                                         // Новый путь
  ctx.moveTo(x, y1); ctx.lineTo(x1, y1);                     // Подготовить горизонтальную линию для полной энергии
  ctx.stroke();                                            // Нарисовать линию
  var xx = x - tU * tPix;                                      // x-координата смещенного начала координат (пиксели)
  var per = tPer * 10;                                       // Период для синусоидальных кривых (пикселей)
  var ampl = e * yPix / 2;                                     // Амплитуда для синусоидальных кривых (пиксель)
  sinus(xx - tPer * 2.5, y - ampl, per, ampl, x, x + 200);              // Синусоида для потенциальной энергии
  sinus(xx - tPer * 7.5, y - ampl, per, ampl, x, x + 200);              // Синусоида для кинетической энергии
}

// Чертеж для энергии:

function drawEnergy() {
  var e = l * alpha0 * omega; e = m * e * e / 2;                     // Полная энергия (Дж)
  var part = cosPhi * cosPhi;                                // Дробная часть для потенциальной энергии
  var eP = e * part, eK = e - eP;                              // Потенциальная и кинетическая энергия (Дж)
  diagramEnergy(xD, yD2, e);                                 // Диаграмма временной зависимости двух форм энергии
  centerTextIndex(symbolEnergy, symbolPotential, xD - 30, yD2 - 125);  // Метка слева (потенциальная энергия)
  alignText(text26, 1, xD - 30, yD2 - 108);                       // Надпись слева (единица J)
  centerTextIndex(symbolEnergy, symbolKinetic, xD + 30, yD2 - 125);    // Надпись справа (кинетическая энергия)
  alignText(text26, 1, xD + 30, yD2 - 108);                       // Надпись справа (единица J)
  ctx.fillStyle = colorElongation;                         // Цвет для потенциальной энергии (соответственно. Элонгация)
  writeValue(text18, eP, joule, 3, xD, xD + 200, height - 70);       // Мгновенное значение потенциальной энергии
  ctx.fillStyle = colorVelocity;                           // Цвет для кинетической энергии
  writeValue(text19, eK, joule, 3, xD, xD + 200, height - 50);       // Мгновенное значение кинетической энергии
  ctx.fillStyle = "#000000";                               // Цвет для полной энергии
  writeValue(text20, e, joule, 3, xD, xD + 200, height - 30);        // Значение полной энергии
  var dy = part * 100;                                       // Высота прямоугольника для потенциальная энергия (пиксели)
  rectangle(300, 205, 50, dy, colorElongation);                // Прямоугольник для потенциальной энергии
  if (part > 0.001 || on)                                  // Если потенциальная энергия не слишком мала ...
    alignText(text18, 0, 360, 220);                           // ... Маркировка потенциальной энергии
  rectangle(300, 205 + dy, 50, 100 - dy, colorVelocity);           // Прямоугольник для кинетической энергии
  if (part < 0.999 || on)                                  // Если кинетическая энергия не слишком мала ...
    alignText(text19, 0, 360, 300);                           // ... Маркировка потенциальной энергии
  drawMomVal(eP, xD, yD2, colorElongation);                   // Маркировка для мгновенной потенциальной энергии
  drawMomVal(eK, xD, yD2, colorVelocity);                     // Маркировка для мгновенной кинетической энергии
}

// Вывод графика:
// Боковой эффект t, tU, phi, sinPhi, cosPhi, альфа, синальфа, косальфа, px, py

function paint() {
  ctx.fillStyle = colorBackground;                         // Цвет фона
  ctx.fillRect(0, 0, width, height);                       // Размытие фона
  rectangle(ax - 50, ay - 5, 100, 5, "");                  // Осветление (потолок)
  if (on) {                                                // Если анимация включена ...
    var t1 = new Date();                                   // ... Текущее время
    var dt = (t1 - t0) / 1000;                             // ... Длительность временного интервала (интервалов)
    if (slow) dt /= 10;                                    // ... В случае замедленного движения разделите временной интервал на 10
    t += dt;                                               // ... Обновить переменную времени
    t0 = t1;                                               // ... Новый начальный момент времени
  }
  tU = (t < 5 ? 0 : t - 5);                                // Время начала (ов) r графика (ов)
  phi = omega * t;                                         // Фазовый угол (дуговое значение)
  sinPhi = Math.sin(phi); cosPhi = Math.cos(phi);          // Тригонометрические значения
  pendulum();                                              // Рисование маятника
 // clock(ax, 340);                                          // Рисование цифровых часов
  switch (nrSize) {                                        // В зависимости от рассматриваемой величины, величина e ...
    case 0: drawElongation(); break;                       // ... Чертеж для удлинения
    case 1: drawVelocity(); break;                         // ... Чертеж для скорости
    case 2: drawAcceleration(); break;                     // ... Чертеж для тангенциального ускорения
    case 3: drawForce(); break;                            // ... Рисунок касательной силы
    case 4: drawEnergy(); break;                           // ... Рисунок энергии
    case 5: ""; break;
  }
  var s = text27 + ":  " + tPer.toPrecision(3) + " " + second;     // Строка длительности колебаний fr r
  s = s.replace(".", decimalSeparator);                     // Возможно, запятая вместо точки
  ctx.fillStyle = "#000000";                               // Цвет текста fr r
  alignText(s, 1, ax, height - 30);                             // Вывод строки длительности колебаний fr r
}

document.addEventListener("DOMContentLoaded", start, false); // После загрузки страницы перейдите к методу запуска